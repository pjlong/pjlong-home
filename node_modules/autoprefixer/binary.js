var CssSyntaxError = require('postcss/lib/css-syntax-error');
var autoprefixer   = require('autoprefixer-core');
var path           = require('path');
var fs             = require('fs-extra');

var Binary = (function(){var DP$0 = Object.defineProperty;var S_ITER$0 = typeof Symbol!=='undefined'&&Symbol.iterator||'@@iterator';function GET_ITER$0(v){if(v){if(Array.isArray(v))return 0;var f;if(typeof v==='object'&&typeof (f=v[S_ITER$0])==='function')return f.call(v);if((v+'')==='[object Generator]')return v;}throw new Error(v+' is not iterable')};"use strict";
    function Binary(process) {
        this.arguments = process.argv.slice(2);
        this.stdin     = process.stdin;
        this.stderr    = process.stderr;
        this.stdout    = process.stdout;

        this.status     = 0;
        this.command    = 'compile';
        this.inputFiles = [];

        this.processOptions   = { };
        this.processorOptions = { };
        this.parseArguments();
    }DP$0(Binary, "prototype", {"configurable": false, "enumerable": false, "writable": false});

    // Quick help message
    Binary.prototype.help = function() {
        return (
("Usage: autoprefixer [OPTION...] FILES\
\n\
\nParse CSS files and add prefixed properties and values.\
\n\
\nOptions:\
\n  -b, --browsers BROWSERS  add prefixes for selected browsers\
\n  -o, --output FILE        set output file\
\n  -d, --dir DIR            set output dir\
\n  -m, --map                generate source map\
\n      --no-map             skip source map even if previous map exists\
\n  -I, --inline-map         inline map by data:uri to annotation comment\
\n      --annotation PATH    change map location relative from CSS file\
\n      --no-map-annotation  skip source map annotation comment is CSS\
\n      --sources-content    Include origin CSS into map\
\n      --no-cascade         do not create nice visual cascade of prefixes\
\n      --safe               tryt of fix CSS syntax errors\
\n  -i, --info               show selected browsers and properties\
\n  -h, --help               show help text\
\n  -v, --version            print program version"));
    }

    // Options description
    Binary.prototype.desc = function() {
        return (
("Files:\
\n  If you didn't set input files, autoprefixer will read from stdin stream.\
\n\
\n  By default, prefixed CSS will rewrite original files.\
\n\
\n  You can specify output file or directory by '-o' argument.\
\n  For several input files you can specify only output directory by '-d'.\
\n\
\n  Output CSS will be written to stdout stream on '-o -' argument or stdin input.\
\n\
\nSource maps:\
\n  On '-m' argument Autoprefixer will generate source map for changes near\
\n  output CSS (for out/main.css it generates out/main.css.map).\
\n\
\n  If previous source map will be near input files (for example, in/main.css\
\n  and in/main.css.map) Autoprefixer will apply previous map to output\
\n  source map.\
\n\
\nBrowsers:\
\n  Separate browsers by comma. For example, '-b \"> 1%, opera 12\"'.\
\n  You can set browsers by global usage statictics: '-b \"> 1%\"'.\
\n  or last version: '-b \"last 2 versions\"'."));
    }

    // Print to stdout
    Binary.prototype.print = function(str) {
        str = str.replace(/\n$/, '');
        this.stdout.write(str + "\n");
    }

    // Print to stdout
    Binary.prototype.error = function(str) {
        this.status = 1;
        this.stderr.write(str + "\n");
    }

    // Get current version
    Binary.prototype.version = function() {
        return require('./package.json').version;
    }

    // Parse arguments
    Binary.prototype.parseArguments = function() {
        var args = this.arguments.slice();
        while ( args.length > 0 ) {
            var arg = args.shift();

            if ( arg == '-h' || arg == '--help' ) {
                this.command = 'showHelp';

            } else if ( arg == '-v' || arg == '--version' ) {
                this.command = 'showVersion';

            } else if ( arg == '-i' || arg == '--info' ) {
                this.command = 'info';

            } else if ( arg == '-m' || arg == '--map' ) {
                this.processOptions.map = { };

            } else if ( arg == '--no-map' ) {
                this.processOptions.map = false;

            } else if ( arg == '-I' || arg == '--inline-map' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.inline = true;

            } else if ( arg == '--annotation' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.annotation = args.shift();

            } else if ( arg == '--no-map-annotation' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.annotation = false;

            } else if ( arg == '--sources-content' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.sourcesContent = true;

            } else if ( arg == '--no-cascade' ) {
                this.processorOptions.cascade = false;

            } else if ( arg == '--safe' ) {
                this.processOptions.safe = true;

            } else if ( arg == '-b' || arg == '--browsers' ) {
                this.processorOptions.browsers = args.shift().split(',')
                  .map( function(i)  {return i.trim()} );

            } else if ( arg == '-o' || arg == '--output' ) {
                this.outputFile = args.shift();

            } else if ( arg == '-d' || arg == '--dir' ) {
                this.outputDir = args.shift();

            } else {
                if ( arg.match(/^-\w$/) || arg.match(/^--\w[\w-]+$/) ) {
                    this.command = undefined;

                    this.error('autoprefixer: Unknown argument ' + arg);
                    this.error('');
                    this.error(this.help());

                } else {
                    this.inputFiles.push(arg);
                }
            }
        }
    }

    // Print help
    Binary.prototype.showHelp = function(done) {
        this.print(this.help());
        this.print('');
        this.print(this.desc());
        done();
    }

    // Print version
    Binary.prototype.showVersion = function(done) {
        this.print('autoprefixer ' + this.version());
        done();
    }

    // Print inspect
    Binary.prototype.info = function(done) {
        this.print(this.compiler().info());
        done();
    }

    // Mark that there is another async work
    Binary.prototype.startWork = function() {
        this.waiting += 1;
    }

    // Execute done callback if there is no works
    Binary.prototype.endWork = function() {
        this.waiting -= 1;
        if ( this.waiting <= 0 ) this.doneCallback();
    }

    // Write error to stderr and finish work
    Binary.prototype.workError = function(str) {
        this.error(str);
        this.endWork();
    }

    // Lazy loading for Autoprefixer instance
    Binary.prototype.compiler = function() {
        if ( !this.compilerCache ) {
          this.compilerCache = autoprefixer(this.processorOptions);
        }
        return this.compilerCache;
    }

    // Compile loaded CSS
    Binary.prototype.compileCSS = function(css, output, input) {var this$0 = this;
        var opts = { };
        for ( var name in this.processOptions ) {
            opts[name] = this.processOptions[name];
        }
        if ( input )         opts.from = input;
        if ( output != '-' ) opts.to   = output;

        var result;
        try {
            result = this.compiler().process(css, opts);
        } catch (error) {
            if ( error.autoprefixer ) {
                this.error('autoprefixer: ' + error.message);
            } else if ( error instanceof CssSyntaxError ) {
                this.error('autoprefixer:' + error.toString());
            } else {
                this.error('autoprefixer: Internal error');
                if ( error.stack ) {
                    this.error('');
                    this.error(error.stack);
                }
            }
        }

        if ( !result ) return this.endWork();

        if ( output == '-' ) {
            this.print(result.css);
            this.endWork();
        } else {
            fs.outputFile(output, result.css, function(error)  {
                if (error) this$0.error('autoprefixer: ' + error);

                if ( result.map ) {
                  var map;
                  if ( opts.map && opts.map.annotation ) {
                      map = path.resolve(path.dirname(output),
                                         opts.map.annotation);
                  } else {
                      map = output + '.map';
                  }
                  fs.writeFile(map, result.map, function(error)  {
                      if (error) this$0.error('autoprefixer: ' + error);
                      this$0.endWork();
                  });
                } else {
                    this$0.endWork();
                }
            });
        }
    }

    // Return input and output files array
    Binary.prototype.files = function() {var $D$0;var $D$1;var $D$2;var $D$3;
        if ( this.inputFiles.length === 0 && !this.outputFile ) {
            this.outputFile = '-';
        }

        var file, list = [];
        if ( this.outputDir ) {
            if ( this.inputFiles.length === 0 ) {
                this.error('autoprefixer: For STDIN input you need ' +
                           'to specify output file (by -o FILE),\n ' +
                           'not output dir');
                return;
            }

            var dir = this.outputDir;
            if ( fs.existsSync(dir) && !fs.statSync(dir).isDirectory() ) {
                this.error('autoprefixer: Path ' + dir +
                           ' is a file, not directory');
                return;
            }

            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ; $D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"]; ){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                var output = path.join(this.outputDir, path.basename(file));
                list.push([file, output]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;

        } else if ( this.outputFile ) {
            if ( this.inputFiles.length > 1 ) {
                this.error('autoprefixer: For several files you can ' +
                           'specify only output dir (by -d DIR`),\n' +
                           'not one output file');
                return;
            }

            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ; $D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"]; ){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                list.push([file, this.outputFile]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;

        } else {
            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ; $D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"]; ){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                list.push([file, file]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;
        }

        return list;
    }

    // Compile selected files
    Binary.prototype.compile = function(done) {var $D$4;var $D$5;var $D$6;var this$0 = this;
        this.waiting      = 0;
        this.doneCallback = done;

        var files = this.files();
        if ( !files ) return done();

        if ( files.length === 0 ) {
            this.startWork();

            var css = '';
            this.stdin.resume();
            this.stdin.on('data', function(chunk)  {return css += chunk});
            this.stdin.on('end', function()  {
                this$0.compileCSS(css, this$0.outputFile);
            });
        } else {
            var file, input, output;
            $D$4 = GET_ITER$0(files);$D$6 = $D$4 === 0;$D$5 = ($D$6 ? files.length : void 0);for ( file ; $D$6 ? ($D$4 < $D$5) : !($D$5 = $D$4["next"]())["done"]; ){file = ($D$6 ? files[$D$4++] : $D$5["value"]);
                this.startWork();
            };$D$4 = $D$5 = $D$6 = void 0;
            $D$4 = GET_ITER$0(files);$D$6 = $D$4 === 0;$D$5 = ($D$6 ? files.length : void 0);for ( file ; $D$6 ? ($D$4 < $D$5) : !($D$5 = $D$4["next"]())["done"]; ){file = ($D$6 ? files[$D$4++] : $D$5["value"]);
                input = file[0], output = file[1], file;

                if ( !fs.existsSync(input) ) {
                    this.workError('autoprefixer: File ' + input +
                                   'doesn\'t exists');
                    continue;
                }

                (function(input, output)  {
                    fs.readFile(input, function(error, css)  {
                        if ( error ) {
                            this$0.workError('autoprefixer: ' + error.message);
                        } else {
                            this$0.compileCSS(css, output, input);
                        }
                    });
                })(input, output);
            };$D$4 = $D$5 = $D$6 = void 0;
        }
    }

    // Execute command selected by arguments
    Binary.prototype.run = function(done) {
        if ( this.command ) {
            this[this.command](done);
        } else {
            done();
        }
    }
;return Binary;})();

module.exports = Binary;
